package main

import (
	"crypto/sha512"
	"encoding/base64"
	"encoding/binary"
	"encoding/hex"
	//"errors"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"runtime"
	//"strconv"
	"strings"
	"sync"
	"time"
)

// Base64 Encoded sha512 sum of given password
func HashPassword(pw string) (string, error) {
	hash := sha512.New()
	_, err := hash.Write([]byte(pw))
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(hash.Sum(nil)), nil
}

type HashId struct {
	Timestamp int64
	Random    int64
}

// Returns nil if str is not a valid hash id
func HashIdFromString(str string) *HashId {
	str = strings.Replace(str, "-", "", -1)
	idBytes, err := hex.DecodeString(str)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil
	}
	id := &HashId{
		Timestamp: int64(binary.BigEndian.Uint64(idBytes[:8])),
		Random:    int64(binary.BigEndian.Uint64(idBytes[8:])),
	}
	log.Println(id)
	return id
}

func (id *HashId) Bytes() []byte {
	buf := make([]byte, 16)
	binary.BigEndian.PutUint64(buf[:8], uint64(id.Timestamp))
	binary.BigEndian.PutUint64(buf[8:], uint64(id.Random))
	return buf
}

func (id *HashId) String() string {
	str := hex.EncodeToString(id.Bytes())
	// pad with zeros
	if len(str) < 32 {
		str = strings.Repeat("0", 32-len(str)) + str
	}
	return fmt.Sprintf("%s-%s-%s-%s-%s", str[:8], str[8:12], str[12:16], str[16:20], str[20:32])
}

// Generates an increasing unique id
//
// A 128 bit identifier is generated by concatenating a 64 bit timestamp with
// a 64 bit random number
func GenerateId() (string, error) {
	id := HashId{
		Timestamp: time.Now().UTC().UnixNano(),
		Random:    rand.Int63(),
	}

	//base64.URLEncoding.EncodeToString(buf), nil
	// fmt.Sprintf("%x-%x", now, random), nil
	return id.String(), nil
}

// A Hasher server
type Server struct {
	HttpServer   *http.Server
	InstanceId   int // Unique id for this server instance
	HashDelay    time.Duration
	hashMap      map[string]string
	hashMapMutex sync.Mutex
}

func NewServer(port int, hashDelay time.Duration) *Server {
	if port < 0 {
		panic("Port cannot be negative")
	}
	server := &Server{
		HttpServer: new(http.Server),
		InstanceId: 42,
		HashDelay:  hashDelay,
		hashMap:    make(map[string]string)}
	mux := http.NewServeMux()
	mux.HandleFunc("/hash", func(w http.ResponseWriter, req *http.Request) {
		server.PutHash(w, req)
	})
	mux.HandleFunc("/hash/", func(w http.ResponseWriter, req *http.Request) {
		server.GetHash(w, req)
	})
	server.HttpServer.Addr = fmt.Sprintf(":%d", port)
	server.HttpServer.Handler = mux
	return server
}

func (server *Server) Close() error {
	return server.HttpServer.Close()
}

func (server *Server) Listen() error {
	return server.HttpServer.ListenAndServe()
}

func (server *Server) PutHash(w http.ResponseWriter, req *http.Request) {
	defer req.Body.Close()
	if req.Method != "POST" {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	err := req.ParseForm()
	if err != nil {
		log.Printf("Failed to parse form: %v\n", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	passwordForm := req.Form["password"]
	if len(passwordForm) < 1 {
		http.Error(w, "Missing password field", http.StatusBadRequest)
		return
	}

	log.Println("JJK GenerateId")
	hashId, err := GenerateId()
	log.Println("JJK GenerateId Done")
	if err != nil {
		log.Printf("GenerateId error: %v\n", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	hash, err := HashPassword(passwordForm[0])
	if err != nil {
		log.Printf("Hash password error: %v\n", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	passwordForm[0] = ""

	go func() {
		time.Sleep(server.HashDelay)
		server.hashMapMutex.Lock()
		defer server.hashMapMutex.Unlock()
		//log.Printf("Inserting id %s", hashId)
		server.hashMap[hashId] = hash
	}()

	io.WriteString(w, hashId)
	//log.Println(req.Form["password"])
}

func (server *Server) GetHash(w http.ResponseWriter, req *http.Request) {
	defer req.Body.Close()
	baseLen := len("/hash/")
	if len(req.URL.Path) == baseLen {
		server.PutHash(w, req)
		return
	}
	if req.Method != "GET" {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	id := HashIdFromString(req.URL.Path[baseLen:])
	if id == nil {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	if id.Timestamp > (time.Now().UTC().Add(-server.HashDelay)).UnixNano() {
		log.Printf("Hash id %v not available yet\n", id)
		w.WriteHeader(http.StatusNotFound)
		return
	}

	server.hashMapMutex.Lock()
	defer server.hashMapMutex.Unlock()
	hash, ok := server.hashMap[id.String()]
	if !ok {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	io.WriteString(w, hash)
}

func main() {
	runtime.GOMAXPROCS(16)
	rand.Seed(time.Now().UTC().UnixNano())

	port := 8080
	server := NewServer(port, 5*time.Second)
	go func() {
		time.Sleep(50 * time.Second)
		server.Close()
	}()
	log.Printf("Starting hasher server on port %d\n", port)
	err := server.Listen()
	if err != nil {
		log.Print(err)
	}
}
